Estrutura do projeto => 

Microframework que será utilizado: Fastify

Por que ele e não o Express?
O Fastify é mais bem mantido, atualizações mais recentes e atualizações constantes
É uma das opções mais utilizadas no Node e é extremamente similar ao Express 
É mais performatico e está melhor preparado para lidar com as novas versões do javascript/typescript na questão do
asincronismo e updates de tipagem, funcionalidades e entre outros.

Oque é um Microframework? Ele não define padrão de arquivos, nem de sistema de teste ou bibliotecas, apenas auxilia no controle das rotas.

Comandos para startar o projeto com typescript =>

npm init -y
npm i -D typescript
npx tsc --init
Alterar o "target" do tsconfig.json para "es2020"
npm i -D @types/node

npx tsc ... => converte o arquivo ts para js para o Node conseguir executar

npm i tsx -D => converte o arquivo ts para js e executa sem criar arquivos fisicos
Agora podemos executar o arquivo .ts diretamente com o comando 
npx tsx ... -> Apenas em desenvolvimento, para dar deploy em produção é altamente recomendado converter para js 

Criar um script para executarmos a aplicação mais facilmente no package.json
"dev": "tsx watch src/server.ts"

Eslint => Processo de padronizar o código mesmo que varias pessoas modifiquem o mesmo código.
Ele formata o código automaticamente quando salvamos o arquivo

Iremos utilizar o banco de dado Sqlite => Banco SQL relacional
É possivel utiliza-lo sem instalar nenhum software adicional na nossa maquina facilitando seu uso para aprendizado
Boa parte das querys são semelhantes aos outros bancos relacionais que utilize SQL

Existem diferentes formas de se comunicar com banco de dados cada uma com diferente proximidade do sql
Drivers nativos: Bibliotecas de baixo nivel, ou seja escrevemos grande parte da query da forma que desejamos executar no banco de dados (mysql2)
Query Buildres: Formas de evitar conexão com sql e focar na linguagem que estamos trabalhando (knex)
ORMs

Iremos utilizar o query builder knex
npm i kenx --save 
npm i {bd} 
npm i knex sqlite3

Migrations => Controle de versão do nosso banco de dados 
    São o histórico de todas as mudanças no banco de dados com data e horário das alterações
    Permite que o banco de dados compartilhado entre mais devs consigam sincronizar o banco de dados evitando conflitos e retrabalhor

Configurar migrations no knex

npx knex -- migrate:make create-tabela

Dá varios erros, porque ele não entende aonde estão as configurações do nosso banco de dados
    para ele entender as configurações do bd ele pede um arquivo knexfile.ts e importamos as configs do nosso banco de dados para lá
    porém está em typescript e ele não entende ts nativamente então precisamos criar um novo script no package.json
    "knex": "node --loader tsx ./node_modules/.bin/knex"
    
Agora para executarmos comandos do knex utilizamos para criar a pasta de migrations na root do projeto
    npm run knex -- ...
Para executarmos as migrations criadas e configuradas
    npm run knex -- migrate:latest

A partir que uma migrations foi enviada para produção do seu time ela nunca mais pode ser editada
Caso exista um erro é preciso criar uma nova migration para corrigir
Caso tenha sido executada apenas na sua própria maquina podemos sim corrigir 
    npm run knex -- migrate:rollback
Depois que dar o rollback você altera o arquivo da migration
    npm run knex -- migrate:latest
E pronto você corrigiu na sua própria maquina

Adionar um campo a tabela que criamos
npm run knex -- migrate:make add-nome_campo-to-nome_tabela